package repository

import (
	"context"
	"fmt"
	"io"
	"log"
	"os"
	"path/filepath"
	"time"

	"google.golang.org/genai"
)

type geminiRepository struct {
	client *genai.Client
}

func NewGeminiRepository() (ComfyUIRepository, error) {
	apiKey := os.Getenv("GEMINI_API_KEY")
	if apiKey == "" {
		return nil, fmt.Errorf("GEMINI_API_KEY environment variable not set")
	}

	ctx := context.Background()
	
	// Create client config with API key
	clientConfig := &genai.ClientConfig{
		APIKey: apiKey,
		Backend: genai.BackendGeminiAPI,
	}
	
	client, err := genai.NewClient(ctx, clientConfig)
	if err != nil {
		return nil, fmt.Errorf("failed to create a new gemini client: %w", err)
	}

	return &geminiRepository{client: client}, nil
}

func (r *geminiRepository) GenerateImage(ctx context.Context, templateID int, imageData io.Reader) ([]string, error) {
	log.Printf("Using Gemini 2.0 Flash Preview for actual image generation - Template ID: %d", templateID)
	
	// Create a descriptive prompt based on template ID
	// In production, you would analyze the input imageData and create more sophisticated prompts
	prompts := map[int]string{
		1: "Create a cyberpunk-style AI portrait with neon lights and futuristic cityscape background, digital art, highly detailed",
		2: "Generate a Van Gogh impressionist-style portrait with swirling brushstrokes and vibrant colors, oil painting style",
		3: "Create a Studio Ghibli anime-style character portrait with soft colors and magical atmosphere, anime art",
		4: "Generate a 3D rendered Pixar-style character portrait with bright lighting and cartoon features, 3D art",
		5: "Create a watercolor painting portrait with soft, flowing colors and artistic brush effects, watercolor art",
	}
	
	prompt, exists := prompts[templateID]
	if !exists {
		prompt = "Generate a beautiful AI portrait in modern artistic style, highly detailed, professional quality"
	}
	
	log.Printf("Generated prompt: %s", prompt)
	
	// Configure for image generation with both text and image output
	config := &genai.GenerateContentConfig{
		ResponseModalities: []string{"TEXT", "IMAGE"},
	}
	
	// Generate content using Gemini 2.0 Flash Preview Image Generation model
	resp, err := r.client.Models.GenerateContent(
		ctx, 
		"gemini-2.0-flash-preview-image-generation", 
		genai.Text(prompt), 
		config,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to generate images from Gemini: %w", err)
	}

	// Process the response and extract generated images
	var imageURLs []string
	if resp != nil && len(resp.Candidates) > 0 {
		log.Printf("Gemini API call successful. Processing response parts...")
		
		for i, part := range resp.Candidates[0].Content.Parts {
			if part.Text != "" {
				log.Printf("Generated text response: %s", part.Text)
			} else if part.InlineData != nil {
				log.Printf("Found generated image in part %d", i)
				
				// Save the image to a temporary location or cloud storage
				// For now, we'll create a unique filename and save locally
				timestamp := time.Now().Unix()
				filename := fmt.Sprintf("generated_image_template_%d_%d_%d.png", templateID, timestamp, i)
				imagePath := filepath.Join("uploads", "generated", filename)
				
				// Get image data (already in bytes format)
				imageBytes := part.InlineData.Data
				
				// Create directory if it doesn't exist
				if err := os.MkdirAll(filepath.Dir(imagePath), 0755); err != nil {
					log.Printf("Warning: Failed to create directory: %v", err)
					continue
				}
				
				// Save image to file
				if err := os.WriteFile(imagePath, imageBytes, 0644); err != nil {
					log.Printf("Warning: Failed to save image: %v", err)
					continue
				}
				
				// Create a URL for the saved image
				imageURL := fmt.Sprintf("/uploads/generated/%s", filename)
				imageURLs = append(imageURLs, imageURL)
				
				log.Printf("Successfully saved generated image: %s", imageURL)
			}
		}
	}

	if len(imageURLs) == 0 {
		return nil, fmt.Errorf("no images were generated by Gemini")
	}

	log.Printf("Generated %d images: %v", len(imageURLs), imageURLs)
	return imageURLs, nil
}

func (r *geminiRepository) Close() error {
	// The genai.Client doesn't have a Close method in this version
	// Resources are managed automatically
	return nil
}