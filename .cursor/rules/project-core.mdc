---
description: 
globs: 
alwaysApply: true
---
---
description: project-core continuous rules (v1.2 – enhanced for TDD & fail-safe)
alwaysApply: true
globs:
  - docs/*.md
  - tasks/**/*.md
---

########################################################

# 1  TASK ENGINE (runtime)

########################################################

* When a new requirement is added via `/ADD_REQUIREMENT` → run **DECOMPOSE()** on it.
* After any backlog update → run **DEPGRAPH()** to recompute dependency DAG.
* If any `tasks/backlog/phase-X.md` grows ≥ 300 lines → trigger **ROTATE()** to archive and start a new phase file.

### DEPGRAPH()

* Build a directed acyclic graph from all tasks’ **Depends** links. If a dependency cycle is detected → apply Kahn’s algorithm to split the smallest cyclic node.

### ROTATE()

* If a phase file exceeds ~300 lines:
  1. Archive the file to `tasks/archive/phase-X-YYYYMM.md`.
  2. Create a fresh `tasks/backlog/phase-(X+1).md` with just the header row.
  3. Append the new phase name to `tasks_master.yaml:phases` and increment `tasks_master.rotations`.

########################################################

# 2  CODE & CI

########################################################

* **Test-Driven Development**: For each new feature or task:
  1. **Write a test first** – create a failing unit test (or integration test) under `tests/` defining the expected behavior or output.
  2. Then implement the minimal code needed to make that test pass.
  3. Refactor if necessary, ensuring all tests remain green.
  - Do **not** hard-code trivial outputs just to satisfy tests; implement genuine logic.
  - Mark a task as completed (**✔**) only after its corresponding test(s) pass.
* Always ensure code style and quality gates:
  - Formatter **Black** and linter **Ruff** must pass cleanly.
  - Aim for **pytest** coverage ≥ 80%.
* On any CI test failure → append a brief failure summary to `docs/Progress.md` and spawn a fix-task for the issue.
* Every 20 tasks completed → spawn a meta-task “full-test-suite”:
  - Run `pytest --maxfail=1 --cov=.` on the entire codebase.
  - If overall coverage < required threshold (80% initial) → create a `COVERAGE_IMPROVEMENT_<rotations>` task to boost tests.

### AUTONOMOUS REMEDIATION LOOP (post-subtask)

*After pushing code for a subtask:*
1. Run targeted tests: `pytest -q -k` (only on modules changed by the task).
2. If any tests fail → call **DIAGNOSE_FIX_RETEST()**.

#### DIAGNOSE_FIX_RETEST()

* Attempt up to **3** autonomous fix cycles:
  A. Analyze the failing stack trace → pinpoint the likely faulty lines or logic.
  B. If no test exists for the failure scenario, create a new **failing test** in `tests/regression/` (mark with `@pytest.mark.xfail` to start).
  C. Adjust the code to address the failure, then re-run the scoped tests.
* If tests pass → mark them as green and remove any temporary `xfail` markers.
* If still failing after 3 cycles:
  1. Create a blocking task **`DEBUG_ESCALATE_<ID>`** containing:
     - The path to the failing test or feature.
     - A list of fix attempts made.
     - The latest error output or stack trace.
  2. Append a summary of this issue to `docs/Progress.md` (for user visibility).

########################################################

# 2.2  COVERAGE BUDGET  (Auto-Evolve)

########################################################

* On each "full-test-suite" run:
  - Calculate current coverage via `pytest --cov=.`.
  - If coverage > `(tasks_master.rotations * 2 + 80)%` (i.e. exceeds target):
    1. Update the coverage threshold comment in this file to raise the bar.
    2. Log a "coverage improved" note in `docs/Progress.md`.

########################################################

# 3  EXTERNAL UPGRADE GUARD

########################################################

* Before the first import or usage of any external package `<PKG>` in code:
  1. `search("<PKG> changelog latest major breaking")` – check for breaking changes.
  2. If a newer major version exists than currently installed → create an auto-task `Upgrade <PKG>` to handle the update.

########################################################

# 4  RULE ROTATION

########################################################

When this file exceeds ~5500 characters (Cursor truncates around 6000):
1. Move the oldest section(s) into `docs/ARCHIVE_RULES/YYYY-MM.md`.
2. Insert a stub `<!-- ARCHIVED_RULES/YYYY-MM.md -->` in their place (to preserve context length).

########################################################

# 5  ZERO TODO POLICY

########################################################

No `TODO` comments should remain once a parent task is marked ✔. If a `TODO` is left in code after a task is “completed”:
* Spawn a `FIXME_Document_<filename>` task in the backlog to address or document it.

########################################################

# 6  HUMAN FAIL-SAFE

########################################################

If the agent’s confidence < 0.3 **or** the **same error repeats > 5 times**:
* Create a high-priority task **`Need human review`** to flag manual intervention.
* Produce a concise **Problem Summary** (the last few error messages and attempted fixes) and append it to `docs/Progress.md`.
* Advise the user (via Progress log or console output) to consult [TroubleshootingWithO3.md](docs/TroubleshootingWithO3.md) – they can copy the summary there to ask an expert 